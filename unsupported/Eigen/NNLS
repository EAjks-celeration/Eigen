/* Non-Negagive Least Squares Algorithm for Eigen.
 *
 * Copyright (C) 2021 Essex Edwards, <essex.edwards@gmail.com>
 * Copyright (C) 2013 Hannes Matuschek, hannes.matuschek at uni-potsdam.de
 *
 * This Source Code Form is subject to the terms of the Mozilla
 * Public License v. 2.0. If a copy of the MPL was not distributed
 * with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/** \defgroup nnls Non-Negative Least Squares (NNLS) Module
 * This module provides a single class @c Eigen::NNLS implementing the NNLS algorithm.
 * The algorithm is described in "SOLVING LEAST SQUARES PROBLEMS", by Charles L. Lawson and
 * Richard J. Hanson, Prentice-Hall, 1974 and solves optimization problems of the form
 *
 * \f[ \min \left\Vert Ax-b\right\Vert_2^2\quad s.t.\, x\ge 0\,.\f]
 *
 * The algorithm solves the constrained least quares (LS) problem above by subsequently solving a
 * subset of the problem called passiv set, i.e. \f$\left\Vert A^Px^P-b\right\Vert_2^2\f$,
 * where \f$A^P\f$ is a matrix formed by selecting all columns of A which are in the passive set
 * \f$P\f$. */

#ifndef EIGEN_NNLS_H
#define EIGEN_NNLS_H

#include "../../Eigen/Core"
#include "../../Eigen/QR"

#include <limits>

namespace Eigen {

/** \ingroup nnls
 * \class NNLS
 * \brief Implementation of the Non-Negative Least Squares (NNLS) algorithm.
 * \param MatrixType The type of the system matrix \f$A\f$.
 *
 * This class implements the NNLS algorithm as described in "SOLVING LEAST SQUARES PROBLEMS",
 * Charles L. Lawson and Richard J. Hanson, Prentice-Hall, 1974. This algorithm solves a least
 * squares problem iteratively and ensures that the solution is non-negative. I.e.
 *
 * \f[ \min \left\Vert Ax-b\right\Vert_2^2\quad s.t.\, x\ge 0 \f]
 *
 * \note Please note that it is possible to construct an NNLS problem for which the algorithm does
 *       not converge. In "nature" these cases are extremely rare. However, you can specify the
 *       maximum number of iterations to avoid endless loops.
 */
template <class MatrixType_>
class NNLS {
 public:
  typedef MatrixType_ MatrixType;

  enum {
    RowsAtCompileTime = MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
    Options = MatrixType::Options,
    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
  };

  typedef typename MatrixType::Scalar Scalar;
  typedef typename MatrixType::RealScalar RealScalar;
  typedef typename MatrixType::Index Index;

  /** Type of a row vector of the system matrix \f$A\f$. */
  typedef Matrix<Scalar, ColsAtCompileTime, 1> RowVectorType;
  /** Type of a column vector of the system matrix \f$A\f$. */
  typedef Matrix<Scalar, RowsAtCompileTime, 1> ColVectorType;
  typedef PermutationMatrix<ColsAtCompileTime, ColsAtCompileTime, Index> PermutationType;
  typedef typename PermutationType::IndicesType IndicesType;

  /** \brief Constructs a NNLS sovler and initializes it with the given system matrix @c A.
   * \param A Specifies the system matrix.
   * \param max_iter Specifies the maximum number of iterations to solve the system.
   * \param tol Specifies the precision of the optimum.
   *        This is an absolute tolerance on the gradient of the Lagrangian, \f$A^T(Ax-b)-\lambda\f$
   *        (with Lagrange multipliers \f$\lambda\f$).
   */
  NNLS(const MatrixType &A, Index max_iter = -1, Scalar tol = NumTraits<Scalar>::dummy_precision())
      : max_iter_(max_iter),
        iterations_(0),
        info_(ComputationInfo::InvalidInput),
        tolerance_(tol),
        A_(A),
        AtA_(A.cols(), A.cols()),
        x_(A.cols()),
        w_(A.cols()),
        y_(A.cols()),
        P_(A.cols()),
        QR_(A.rows(), A.cols()),
        qrCoeffs_(A.cols()),
        tempRowVector_(A.cols()),
        tempColVector_(A.rows()) {
    // Ensure Scalar type is real.
    EIGEN_STATIC_ASSERT(!NumTraits<Scalar>::IsComplex, NUMERIC_TYPE_MUST_BE_REAL);

    // Precompute A^T*A
    AtA_ = A.transpose() * A;
  }

  /** \brief Solves the NNLS problem.
   *
   * The dimension of @c b must be equal to the number of rows of @c A, given to the constructor.
   *
   * \returns The approximate solution vector \f$ x \f$. Use info() to determine if the solve was a success or not.
   * \sa info()
   */
  const RowVectorType &solve(const ColVectorType &b);

  /** \brief Returns the solution if a problem was solved.
   * If not, an uninitialized vector may be returned. */
  inline const RowVectorType &x() const { return x_; }

  /** \returns the tolerance threshold used by the stopping criteria.
   * \sa setTolerance()
   */
  Scalar tolerance() const { return tolerance_; }

  /** Sets the tolerance threshold used by the stopping criteria.
   *
   * This is an absolute tolerance on the gradient of the Lagrangian, \f$A^T(Ax-b)-\lambda\f$
   * (with Lagrange multipliers \f$\lambda\f$).
   */
  NNLS<MatrixType> &setTolerance(const Scalar &tolerance) {
    tolerance_ = tolerance;
    return *this;
  }

  /** \returns the max number of iterations.
   * It is either the value set by setMaxIterations or, by default, twice the number of columns of the matrix.
   */
  Index maxIterations() const { return max_iter_ < 0 ? 2 * A_.cols() : max_iter_; }

  /** Sets the max number of iterations.
   * Default is twice the number of columns of the matrix.
   * The algorithm requires at least k iterations to produce a solution vector with k non-zero entries.
   */
  NNLS<MatrixType> &setMaxIterations(Index maxIters) {
    max_iter_ = maxIters;
    return *this;
  }

  /** \returns the number of iterations (least-squares solves) performed during the last solve */
  Index iterations() const { return iterations_; }

  /** \returns Success if the iterations converged, and an error values otherwise. */
  ComputationInfo info() const { return info_; }

 protected:
  /** Searches for the index in Z with the largest value of @c v
   *  (\f$argmax v^P\f$) . */
  Index argmax_Z_(const RowVectorType &v) {
    const IndicesType &idxs = P_.indices();
    Index m_idx = Np_;
    Scalar m = v(idxs(m_idx));
    for (Index i = (Np_ + 1); i < A_.cols(); i++) {
      Index idx = idxs(i);
      if (m < v(idx)) {
        m = v(idx);
        m_idx = i;
      }
    }
    return m_idx;
  }

  /** Searches for the largest value in \f$v^Z\f$. */
  Scalar max_Z_(const RowVectorType &v) {
    const IndicesType &idxs = P_.indices();
    Scalar m = v(idxs(Np_));
    for (Index i = (Np_ + 1); i < A_.cols(); i++) {
      Index idx = idxs(i);
      if (m < v(idx)) {
        m = v(idx);
      }
    }
    return m;
  }

  /** Searches for the smallest value in \f$v^P\f$. */
  Scalar min_P_(const RowVectorType &v) {
    eigen_assert(Np_ > 0);
    const IndicesType &idxs = P_.indices();
    Scalar m = v(idxs(0));
    for (Index i = 1; i < Np_; i++) {
      Index idx = idxs(i);
      if (m > v(idx)) {
        m = v(idx);
      }
    }
    return m;
  }

  /** Adds the given index @c idx to the set P and updates the QR decomposition of \f$A^P\f$. */
  void addToP_(Index idx);

  /** Removes the given index idx from the set P and updates the QR decomposition of \f$A^P\f$. */
  void removeFromP_(Index idx);

  /** Solves the LS problem \f$\left\Vert y-A^Px\right\Vert_2^2\f$. */
  void solveLS_P_(const ColVectorType &b);

  /** Updates the gradient \c w_ using the current partial solution \c x_. */
  void updateGradient_() {
    // w <- A^T b - A^TA x
    w_ = Atb_ - AtA_ * x_;
  }

 protected:
  typedef Matrix<Scalar, ColsAtCompileTime, ColsAtCompileTime> MatrixAtAType;

  /** Holds the maximum number of iterations for the NNLS algorithm, @c -1 means that there is no
   * limit. */
  Index max_iter_;
  /** Holds the number of iterations. */
  Index iterations_;
  /** Holds success/fail of the last solve. */
  ComputationInfo info_;
  /** Size of the P (passive) set. */
  Index Np_;
  /** Accuracy of the algorithm w.r.t the optimality of the solution (gradient). */
  Scalar tolerance_;
  /** The system matrix, a copy of the one given to the constructor. */
  MatrixType A_;
  /** Precomputed product \f$A^TA\f$. */
  MatrixAtAType AtA_;
  /** Will hold the solution. */
  RowVectorType x_;
  /** Will hold the current gradient. */
  RowVectorType w_;
  /** Will hold the partial solution. */
  RowVectorType y_;
  /** Precomputed product \f$A^Tb\f$. */
  RowVectorType Atb_;
  /** Holds the current permutation matrix, the first @c Np_ columns form the set P and the rest
   * the set Z. */
  PermutationType P_;
  /** QR decomposition to solve the (passive) sub system (together with @c qrCoeffs_). */
  MatrixType QR_;
  /** QR decomposition to solve the (passive) sub system (together with @c QR_). */
  RowVectorType qrCoeffs_;
  /** Some workspace for QR decomposition. */
  RowVectorType tempRowVector_;
  ColVectorType tempColVector_;
};

/* ********************************************************************************************
 * Implementation
 * ******************************************************************************************** */

namespace internal {

/** Basically a modified copy of @c Eigen::internal::householder_qr_inplace_unblocked that
 * performs a rank-1 update of the QR matrix in compact storage. This function assumes, that
 * the first @c k-1 columns of the matrix @c mat contain the QR decomposition of \f$A^P\f$ up to
 * column k-1. Then the QR decomposition of the k-th column (given by @c newColumn) is computed by
 * applying the k-1 Householder projectors on it and finally compute the projector \f$H_k\f$ of
 * it. On exit the matrix @c mat and the vector @c hCoeffs contain the QR decomposition of the
 * first k columns of \f$A^P\f$. */
template <typename MatrixQR, typename HCoeffs, typename VectorQR>
void nnls_householder_qr_inplace_update(MatrixQR &mat, HCoeffs &hCoeffs, const VectorQR &newColumn,
                                        typename MatrixQR::Index k, typename MatrixQR::Scalar *tempData = 0) {
  typedef typename MatrixQR::Index Index;
  typedef typename MatrixQR::Scalar Scalar;
  typedef typename MatrixQR::RealScalar RealScalar;
  Index rows = mat.rows();

  eigen_assert(k < mat.cols());
  eigen_assert(k < rows);
  eigen_assert(hCoeffs.size() == mat.cols());
  eigen_assert(newColumn.size() == rows);

  Matrix<Scalar, Dynamic, 1, ColMajor, MatrixQR::MaxColsAtCompileTime, 1> tempVector;
  if (tempData == 0) {
    tempVector.resize(mat.cols());
    tempData = tempVector.data();
  }

  // Store new column in mat at column k
  mat.col(k) = newColumn;
  // Apply H = H_1...H_{k-1} on newColumn (skip if k=0)
  for (Index i = 0; i < k; ++i) {
    Index remainingRows = rows - i;
    mat.col(k)
        .tail(remainingRows)
        .applyHouseholderOnTheLeft(mat.col(i).tail(remainingRows - 1), hCoeffs.coeffRef(i), tempData + i + 1);
  }
  // Construct Householder projector in-place in column k
  RealScalar beta;
  mat.col(k).tail(rows - k).makeHouseholderInPlace(hCoeffs.coeffRef(k), beta);
  mat.coeffRef(k, k) = beta;
}

/** Solves the system Ax=b, where A is given as its QR decomposition in the first @c rank columns
 * in @c mat. */
template <typename MatrixQR, typename HCoeffs, typename Dest>
void nnls_householder_qr_inplace_solve(const MatrixQR &mat, const HCoeffs &hCoeffs, Dest &c,
                                       typename MatrixQR::Index &rank) {
  eigen_assert(mat.rows() == c.size());
  eigen_assert(mat.cols() == hCoeffs.size());
  eigen_assert(mat.cols() >= rank);

  c.applyOnTheLeft(householderSequence(mat.leftCols(rank), hCoeffs.head(rank)).transpose());

  mat.topLeftCorner(rank, rank).template triangularView<Upper>().solveInPlace(c.head(rank));
}
}  // namespace internal

template <typename MatrixType>
const typename NNLS<MatrixType>::RowVectorType &NNLS<MatrixType>::solve(const ColVectorType &b) {
  // Initialize solver
  iterations_ = 0;
  info_ = ComputationInfo::NumericalIssue;
  x_.setZero();

  // Together with Np_, P separates the space of coefficients into a active (Z) and passive (P)
  // set. The first Np_ elements form the passive set P and the remaining elements form the
  // active set Z.
  P_.setIdentity();
  Np_ = 0;

  // Precompute A^T*b
  Atb_ = A_.transpose() * b;

  const Index maxIterations = this->maxIterations();

  // OUTER LOOP
  while (true) {
    // Update gradient w_
    updateGradient_();

    // Check if system is solved:
    if ((A_.cols() == Np_) || ((max_Z_(w_) - tolerance_) < 0)) {
      info_ = ComputationInfo::Success;
      return x_;
    }

    // We need a heuristic to choose the next parameter for the system update.
    // We choose the one with largest gradient.
    // Other heuristics are possible, but unimplemented.
    // Here is where those other options would go.
    addToP_(argmax_Z_(w_));

    // INNER LOOP
    while (true) {
      // Check if max. number of iterations is reached
      if (iterations_ >= maxIterations) {
        info_ = ComputationInfo::NoConvergence;
        return x_;
      }

      // Solve LS problem in P only, this step is rather trivial as addToP_ & removeFromP_
      // updates the QR decomposition of A^P.
      solveLS_P_(b);

      // Check feasability...
      bool feasible = true;
      Scalar alpha = NumTraits<Scalar>::highest();
      Index remIdx = -1;
      for (Index i = 0; i < Np_; i++) {
        Index idx = P_.indices()(i);
        if (y_(idx) < 0) {
          // t should always be in [0,1].
          Scalar t = -x_(idx) / (y_(idx) - x_(idx));
          if (alpha > t) {
            alpha = t;
            remIdx = i;
            feasible = false;
          }
        }
      }
      eigen_assert(feasible || 0 <= remIdx);

      // If solution is feasible, exit to outer loop
      if (feasible) {
        x_ = y_;
        break;
      }

      // Infeasible solution -> interpolate to feasible one
      for (Index i = 0; i < Np_; i++) {
        Index idx = P_.indices()(i);
        x_(idx) += alpha * (y_(idx) - x_(idx));
      }

      // Remove these indices from P and update QR decomposition
      removeFromP_(remIdx);
    }
  }
}

template <typename MatrixType>
void NNLS<MatrixType>::addToP_(Index idx) {
  // Update permutation matrix:
  IndicesType &idxs = P_.indices();

  std::swap(idxs(idx), idxs(Np_));
  Np_++;

  // Perform rank-1 update of the QR decomposition stored in QR_ & qrCoeff_
  internal::nnls_householder_qr_inplace_update(QR_, qrCoeffs_, A_.col(idxs(Np_ - 1)), Np_ - 1, tempRowVector_.data());
}

template <typename MatrixType>
void NNLS<MatrixType>::removeFromP_(Index idx) {
  // swap index with last passive one & reduce number of passive columns
  std::swap(P_.indices()(idx), P_.indices()(Np_ - 1));
  Np_--;
  // Update QR decomposition starting from the removed index up to the end [idx, ..., Np_]
  for (Index i = idx; i < Np_; i++) {
    Index col = P_.indices()(i);
    internal::nnls_householder_qr_inplace_update(QR_, qrCoeffs_, A_.col(col), i, tempRowVector_.data());
  }
}

template <typename MatrixType>
void NNLS<MatrixType>::solveLS_P_(const ColVectorType &b) {
  eigen_assert(Np_ > 0);

  // Solve in permuted sub space
  tempColVector_ = b;
  internal::nnls_householder_qr_inplace_solve(QR_, qrCoeffs_, tempColVector_, Np_);
  y_.head(Np_) = tempColVector_.head(Np_);
  y_.tail(y_.size() - Np_).setZero();

  // Back permute y into original column order of A
  y_ = P_ * y_;

  iterations_++;
}

}  // namespace Eigen

#endif  // EIGEN_NNLS_H
